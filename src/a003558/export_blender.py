# src/a003558/export_blender.py
"""
Minimal OBJ export helpers (headless) for tests and static assets.

Functions:
- export_octa_cube_obj(out_dir, basename="scene", cube_size=2.0, octa_radius=1.5) -> dict[str, str]
    Writes:
      - {basename}_octahedron.obj
      - {basename}_cube.obj
      - {basename}_scene.obj  (multi-group: "octahedron" + "cube")
    Returns dict with created file paths.

- export_label_spheres_obj(out_dir, basename="labels", labels=None, radius=0.2, spacing=1.0) -> str
    Writes:
      - {basename}.obj (multi-group; each label as a small cube proxy)
"""

from __future__ import annotations
import os
from typing import Iterable, List, Tuple, Dict


# ---------- low-level writers ----------

def _write_obj_single(path: str,
                      verts: Iterable[Tuple[float, float, float]],
                      faces: Iterable[Tuple[int, ...]],
                      group_name: str | None = None) -> None:
    """Write a single-mesh OBJ. Faces are 1-based index tuples."""
    with open(path, "w", encoding="utf-8") as f:
        f.write("# minimal OBJ generated by a003558.export_blender\n")
        if group_name:
            f.write(f"g {group_name}\n")
        v = list(verts)
        for x, y, z in v:
            f.write(f"v {x:.6f} {y:.6f} {z:.6f}\n")
        for face in faces:
            f.write("f " + " ".join(str(i) for i in face) + "\n")


def _write_obj_groups(path: str,
                      meshes: List[Tuple[str,
                                         Iterable[Tuple[float, float, float]],
                                         Iterable[Tuple[int, ...]]]]) -> None:
    """
    Write one OBJ file with multiple 'g' groups.
    Each entry: (group_name, vertices, faces). Faces use 1-based indices.
    Indices are concatenated globally (OBJ-style) across groups.
    """
    with open(path, "w", encoding="utf-8") as f:
        f.write("# minimal multi-group OBJ generated by a003558.export_blender\n")
        vcount = 0
        for gname, verts, faces in meshes:
            verts_l = list(verts)
            faces_l = list(faces)
            f.write(f"g {gname}\n")
            for x, y, z in verts_l:
                f.write(f"v {x:.6f} {y:.6f} {z:.6f}\n")
            for face in faces_l:
                f.write("f " + " ".join(str(vcount + i) for i in face) + "\n")
            vcount += len(verts_l)


# ---------- primitive meshes ----------

def _cube(center: Tuple[float, float, float], size: float) -> Tuple[List[Tuple[float, float, float]],
                                                                    List[Tuple[int, int, int, int]]]:
    """Axis-aligned cube, quad faces, 1-based indices."""
    cx, cy, cz = center
    s = size / 2.0
    verts = [
        (cx - s, cy - s, cz - s),  # 1
        (cx + s, cy - s, cz - s),  # 2
        (cx + s, cy + s, cz - s),  # 3
        (cx - s, cy + s, cz - s),  # 4
        (cx - s, cy - s, cz + s),  # 5
        (cx + s, cy - s, cz + s),  # 6
        (cx + s, cy + s, cz + s),  # 7
        (cx - s, cy + s, cz + s),  # 8
    ]
    faces = [
        (1, 2, 3, 4),
        (5, 6, 7, 8),
        (1, 2, 6, 5),
        (4, 3, 7, 8),
        (1, 5, 8, 4),
        (2, 3, 7, 6),
    ]
    return verts, faces


def _octahedron(center: Tuple[float, float, float], r: float) -> Tuple[List[Tuple[float, float, float]],
                                                                       List[Tuple[int, int, int]]]:
    """Regular octahedron (8 triangles), 1-based indices."""
    cx, cy, cz = center
    verts = [
        (cx,     cy,     cz + r),  # 1 top
        (cx,     cy,     cz - r),  # 2 bottom
        (cx + r, cy,     cz),      # 3 +x
        (cx - r, cy,     cz),      # 4 -x
        (cx,     cy + r, cz),      # 5 +y
        (cx,     cy - r, cz),      # 6 -y
    ]
    faces = [
        (1, 3, 5), (1, 5, 4), (1, 4, 6), (1, 6, 3),
        (2, 5, 3), (2, 4, 5), (2, 6, 4), (2, 3, 6),
    ]
    return verts, faces


# ---------- public API ----------

def export_octa_cube_obj(out_dir: str,
                         basename: str = "scene",
                         *,
                         cube_size: float = 2.0,
                         octa_radius: float = 1.5) -> Dict[str, str]:
    """
    Export three OBJ files:
      - {basename}_octahedron.obj
      - {basename}_cube.obj
      - {basename}_scene.obj  (multi-group with both)

    Returns:
      dict with keys: 'octahedron', 'cube', 'scene' → file paths.
    """
    os.makedirs(out_dir, exist_ok=True)

    # Build meshes
    v_oct, f_oct = _octahedron((0.0, 0.0, 0.0), octa_radius)
    v_cub, f_cub = _cube((0.0, 0.0, 0.0), cube_size)

    # Individual files
    p_octa = os.path.join(out_dir, f"{basename}_octahedron.obj")
    p_cube = os.path.join(out_dir, f"{basename}_cube.obj")
    _write_obj_single(p_octa, v_oct, f_oct, group_name="octahedron")
    _write_obj_single(p_cube, v_cub, f_cub, group_name="cube")

    # Combined scene (two groups)
    p_scene = os.path.join(out_dir, f"{basename}_scene.obj")
    _write_obj_groups(p_scene, [
        ("octahedron", v_oct, f_oct),
        ("cube",       v_cub, f_cub),
    ])

    return {"octahedron": p_octa, "cube": p_cube, "scene": p_scene}


def export_label_spheres_obj(out_dir: str | None = None,
                             basename: str = "labels",
                             *,
                             labels: Iterable[str] | None = None,
                             radius: float = 0.2,
                             spacing: float = 1.0,
                             path: str | None = None) -> str:
    """
    Export a simple multi-group OBJ where each label is represented by a small cube
    (sphere proxy). Returns the full path to the written OBJ.
    """

    # --- bepaal outputpad één keer, geen herberekening later ---
    if path:  # pytest gebruikt dit pad-argument
        out_path = path
        out_dir_eff = os.path.dirname(out_path) or "."
        os.makedirs(out_dir_eff, exist_ok=True)
    else:
        if out_dir is None:
            out_dir = "."
        os.makedirs(out_dir, exist_ok=True)
        out_path = os.path.join(out_dir, f"{basename}.obj")
    # -----------------------------------------------------------

    if labels is None:
        labels = ["A", "B", "C"]

    def cube_mesh(center: Tuple[float, float, float], r: float):
        return _cube(center, 2.0 * r)

    meshes = []
    for idx, lab in enumerate(labels):
        cx = idx * spacing
        verts, faces = cube_mesh((cx, 0.0, 0.0), radius)
        meshes.append((f"label_{lab}", verts, faces))

    out_path = os.path.join(out_dir, f"{basename}.obj")
    _write_obj_groups(out_path, meshes)
    return out_path
