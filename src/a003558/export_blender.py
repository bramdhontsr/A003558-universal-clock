# src/a003558/export_blender.py
from __future__ import annotations
from pathlib import Path
from typing import Dict, Union, Iterable

Number = Union[int, float]


def _write_obj(path: Path, verts: Iterable[Iterable[Number]], faces: Iterable[Iterable[int]]):
    """
    Schrijf een minimaal .obj-bestand.
    verts: iterable van (x,y,z)
    faces: iterable van 1-based indices, b.v. (1,2,3)
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        f.write("# Minimal OBJ generated by a003558.export_blender\n")
        for v in verts:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
        for face in faces:
            f.write("f " + " ".join(str(i) for i in face) + "\n")


def _cube_geometry(size: float = 1.0):
    s = size / 2.0
    verts = [
        (-s, -s, -s), ( s, -s, -s), ( s,  s, -s), (-s,  s, -s),
        (-s, -s,  s), ( s, -s,  s), ( s,  s,  s), (-s,  s,  s),
    ]
    faces = [
        (1, 2, 3), (1, 3, 4),  # bottom
        (5, 6, 7), (5, 7, 8),  # top
        (1, 2, 6), (1, 6, 5),
        (2, 3, 7), (2, 7, 6),
        (3, 4, 8), (3, 8, 7),
        (4, 1, 5), (4, 5, 8),
    ]
    return verts, faces


def _octa_geometry(size: float = 1.0):
    s = size / 2.0
    verts = [
        ( 0,  0,  s),
        ( 0,  0, -s),
        ( s,  0,  0),
        (-s,  0,  0),
        ( 0,  s,  0),
        ( 0, -s,  0),
    ]
    faces = [
        (1, 3, 5),
        (1, 5, 4),
        (1, 4, 6),
        (1, 6, 3),
        (2, 5, 3),
        (2, 4, 5),
        (2, 6, 4),
        (2, 3, 6),
    ]
    return verts, faces


def export_octa_cube_obj(
    out_dir: Union[str, Path],
    base: str = "a003558",
    cube_size: float = 2.0,
    octa_size: float = 2.0,
) -> Dict[str, Path]:
    """
    Schrijft drie OBJ-bestanden:
      - {base}_cube.obj
      - {base}_octahedron.obj
      - {base}_scene.obj (beide meshes in één bestand)
    Returnt paden in een dict.
    """
    out_dir = Path(out_dir)
    cube_path = out_dir / f"{base}_cube.obj"
    octa_path = out_dir / f"{base}_octahedron.obj"
    scene_path = out_dir / f"{base}_scene.obj"

    # losse bestanden
    c_verts, c_faces = _cube_geometry(cube_size)
    _write_obj(cube_path, c_verts, c_faces)

    o_verts, o_faces = _octa_geometry(octa_size)
    _write_obj(octa_path, o_verts, o_faces)

    # gecombineerde scene (offset de octa een tikje, zodat beide net niet samenvallen)
    o2 = [(x + cube_size * 0.75, y, z) for (x, y, z) in o_verts]
    verts = c_verts + o2
    faces = c_faces + [(a+len(c_verts), b+len(c_verts), c+len(c_verts)) for (a, b, c) in o_faces]
    _write_obj(scene_path, verts, faces)

    return {"cube": cube_path, "octahedron": octa_path, "scene": scene_path}


def export_label_spheres_obj(
    out_dir: Union[str, Path],
    base: str = "labels",
    centers: Iterable[Iterable[Number]] = ((0,0,0),),
    radius: float = 0.1,
    rings: int = 8,
    segments: int = 16,
) -> Path:
    """
    Schrijft een OBJ met kleine 'sferen' (poly-spheres) op opgegeven locaties.
    Voor tests is een ruwe bol voldoende (lat/lon triangulatie).
    """
    out_path = Path(out_dir) / f"{base}_spheres.obj"
    out_path.parent.mkdir(parents=True, exist_ok=True)

    verts_all = []
    faces_all = []
    vcount = 0

    import math

    for cx, cy, cz in centers:
        verts = []
        for i in range(rings + 1):
            theta = math.pi * i / rings
            sin_t, cos_t = math.sin(theta), math.cos(theta)
            for j in range(segments):
                phi = 2 * math.pi * j / segments
                x = cx + radius * sin_t * math.cos(phi)
                y = cy + radius * sin_t * math.sin(phi)
                z = cz + radius * cos_t
                verts.append((x, y, z))

        # faces (quad-strip triangulated)
        faces = []
        for i in range(rings):
            for j in range(segments):
                a = i * segments + j
                b = i * segments + (j + 1) % segments
                c = (i + 1) * segments + (j + 1) % segments
                d = (i + 1) * segments + j
                faces.append((a+1+vcount, b+1+vcount, c+1+vcount))
                faces.append((a+1+vcount, c+1+vcount, d+1+vcount))

        verts_all.extend(verts)
        faces_all.extend(faces)
        vcount += len(verts)

    _write_obj(out_path, verts_all, faces_all)
    return out_path
