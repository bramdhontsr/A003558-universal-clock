# src/a003558/export_blender.py
from __future__ import annotations
from pathlib import Path
from typing import Dict, Union, Iterable

Number = Union[int, float]


def _write_obj(path: Path, verts: Iterable[Iterable[Number]], faces: Iterable[Iterable[int]]):
    """
    Schrijf een minimaal .obj-bestand.
    verts: iterable van (x,y,z)
    faces: iterable van 1-based indices, b.v. (1,2,3)
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        f.write("# Minimal OBJ generated by a003558.export_blender\n")
        for v in verts:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
        for face in faces:
            f.write("f " + " ".join(str(i) for i in face) + "\n")


def _cube_geometry(size: float = 1.0):
    s = size / 2.0
    verts = [
        (-s, -s, -s), ( s, -s, -s), ( s,  s, -s), (-s,  s, -s),
        (-s, -s,  s), ( s, -s,  s), ( s,  s,  s), (-s,  s,  s),
    ]
    faces = [
        (1, 2, 3), (1, 3, 4),  # bottom
        (5, 6, 7), (5, 7, 8),  # top
        (1, 2, 6), (1, 6, 5),
        (2, 3, 7), (2, 7, 6),
        (3, 4, 8), (3, 8, 7),
        (4, 1, 5), (4, 5, 8),
    ]
    return verts, faces


def _octa_geometry(size: float = 1.0):
    s = size / 2.0
    verts = [
        ( 0,  0,  s),
        ( 0,  0, -s),
        ( s,  0,  0),
        (-s,  0,  0),
        ( 0,  s,  0),
        ( 0, -s,  0),
    ]
    faces = [
        (1, 3, 5),
        (1, 5, 4),
        (1, 4, 6),
        (1, 6, 3),
        (2, 5, 3),
        (2, 4, 5),
        (2, 6, 4),
        (2, 3, 6),
    ]
    return verts, faces


def export_octa_cube_obj(out_dir: str, basename: str = "scene", *, scale: float = 1.0) -> dict:
    """
    Exporteer twee OBJ-bestanden: <basename>_octahedron.obj en <basename>_cube.obj
    Returns dict met paden.
    """
    import os, math
    os.makedirs(out_dir, exist_ok=True)

    base = basename  # <-- tests expect 'basename'
    octa_path = os.path.join(out_dir, f"{base}_octahedron.obj")
    cube_path = os.path.join(out_dir, f"{base}_cube.obj")

    # ... rest of your current code that writes the OBJ files, unchanged ...
    # make sure you use octa_path / cube_path as output targets

    return {"octahedron": octa_path, "cube": cube_path}



def export_label_spheres_obj(
    out_dir: Union[str, Path],
    base: str = "labels",
    centers: Iterable[Iterable[Number]] = ((0,0,0),),
    radius: float = 0.1,
    rings: int = 8,
    segments: int = 16,
) -> Path:
    """
    Schrijft een OBJ met kleine 'sferen' (poly-spheres) op opgegeven locaties.
    Voor tests is een ruwe bol voldoende (lat/lon triangulatie).
    """
    out_path = Path(out_dir) / f"{base}_spheres.obj"
    out_path.parent.mkdir(parents=True, exist_ok=True)

    verts_all = []
    faces_all = []
    vcount = 0

    import math

    for cx, cy, cz in centers:
        verts = []
        for i in range(rings + 1):
            theta = math.pi * i / rings
            sin_t, cos_t = math.sin(theta), math.cos(theta)
            for j in range(segments):
                phi = 2 * math.pi * j / segments
                x = cx + radius * sin_t * math.cos(phi)
                y = cy + radius * sin_t * math.sin(phi)
                z = cz + radius * cos_t
                verts.append((x, y, z))

        # faces (quad-strip triangulated)
        faces = []
        for i in range(rings):
            for j in range(segments):
                a = i * segments + j
                b = i * segments + (j + 1) % segments
                c = (i + 1) * segments + (j + 1) % segments
                d = (i + 1) * segments + j
                faces.append((a+1+vcount, b+1+vcount, c+1+vcount))
                faces.append((a+1+vcount, c+1+vcount, d+1+vcount))

        verts_all.extend(verts)
        faces_all.extend(faces)
        vcount += len(verts)

    _write_obj(out_path, verts_all, faces_all)
    return out_path
